Have you gone through : HTTP Basics n web server basics  ?

Today's Topics
Revise JDBC Steps
JDBC CRUD Application with layered architecture
Java App ---DAO i/f & implementation Class --DBUtils -- POJO --DB
Stored procedure/function
Enter web prog in Java


Revise

What is JDBC ? : An API to connect to DB , query DB , perform DDL /DML operations

Which are the packages ? 
1. java.sql ---class --DriverManager.getConnection(url,userName,pwd) ---actually fetches the db conn n rets to the caller. (FIXED connectivity)

2. javax.sql --DataSource.getConnection() -- represents pooled out DB connection.

Why JDBC ? :JDBC apps are :  Platform independent + DB vendor inde.(partially: meaning if sql syntax changes from DB to DB , you have to make changes in the code)

Other than SQL --JDBC Driver has to be replaced in DB specific manner

What are DB specific config params -- 4
1. JDBC Driver class
eg : Class.forName("com.mysql.cj.jdbc.Driver") ---OPTIONAL
2. DB URL
eg : MySQL --- jdbc:mysql://localhost:3306/dac22?.....
Oracle -- jdbc:oracle:thin:@localhost:1520:xe
3 user name
4 pwd

Currently we are hard coding these details in : DBUtils , later to be added in config xml files.



How JDBC offers partial DB independence ? : 
1. JDBC Driver : connector (translator --2 way : java <---> DB )
2. JDBC  API : java.sql ---consists of largely i/fs : eg : Connection,ST,PST,RST,CST... : specs
Imple classes : JDBC JAR : provided by DB vendors or 3rd party vendors
eg : MySQL : mysql connector . jar

What is JDBC Driver ?  : connector
Types : (refer to slides)
Type IV JDBC Driver : pure java driver using vendor specific native protocol
side effect : changes will have to be made in DB URL , when you change the DB


Generalized steps in JDBC 
1. Add JDBC jar in run time cls path
2. get fixed db conn. (D.M.getConn(url,name,pwd))
3. create statement
Statement <---- PST <---- CST : i/f
4. exec methods
execQuery , execUpdate,exec
5. close all db resources.


Layered DB application
Tester(main class) ---DAL / DAO (i/f <----class) --DBUtils: to get fixed DB conn ---POJO/s(Model / Entity / Domain / DTO)---DB  (EIS layer)
ORM : object to relational mapping : JDBC
Table ---POJO/Model/Entity/DTO class
Columns -- Properties (non static n non transient data members)
rows --POJO

JDBC based DAO impl class
1. public n pkged class
2. import pkg : java.sql
3. state : Connection , sts/psts/csts
4. def ctor ---will be invoked exactly once by the layer abover(eg : Tester)
one time jobs (init time jobs) 
get the cn from DBUtils
creats psts n csts n keep them rdy
5. CRUD  method
will be invoked by tester --multiple times (once per request) : service
6. Clean Up style method 
will be invoked once by the layer abover(eg : Tester) --exactly once @ app destroy time (ie closing app)
---------------------------------------------------

Objectives
0. Get emp details by it's dept n join date

1. Table : my_emp
2. POJO : Employee
3. DAO i/f
List<Employee> getEmpDetails(in params) throws SE




1. Insert new  emp details  in the DB

1.1 DB Table : no change
1.2 POJO : no change
1.3 DB Utils : no change
1.4 DAO i/f : 
String  insertEmpDetails(Employee emp) throws SE;
1.5 DAO impl
state : pst2
ctor : pst2=....
clean up : pst2 close
CRUD method : set in params , execUpdate --update cnt --send mesg to the caller



2. Update emp details ---salary n dept
user i/p : sal incr , new dept , emp id
Steps
2.1 DB --no change
2.2 POJO -- no change
2.3 DBUtils -- no change
2.4 DAO i/f --new method 
String updateEmpDetails(sal incr , new dept , emp id) throws SE
2.5 DAO impl 
state : pst3
ctor : pst3=cn.prepareSt("update my_emp set salary=salary+? , deptid=? where empid=?");
clean up : close pst3
CRUD : set IN params , exec update --> update count --> ret mesg




3. Remove emp details
i/p : emp id
------------------------------------


Execute stored procedure : transfer funds
Steps
1. Stored proc/func exists in DB

2. Create CST(CallableStatement) from DB connection. => pre-parsed , pre compiled statement
API of Connection i/f
public CST prepareCall(String sql) throws SQLExc.
sql : proc : "{call procName(?,?,?,?....)}"
sql : func : "{?=call funcName(?,?,?,?....)}"
{} : esc sequence meant for JDBC driver , to translate invocation syntax into DB specific invocation syntax

3. Register OUT params => Informing JVM about JDBC data type (generic SQL type : DB independent )  of OUT param.
API of  CST 
public void registerOutParameter(int paramPos,int jdbcType) throws SQLException


4. IN : set it's value : public void setType(int paramIndex,Type value) throws SE
OUT :  public void registerOutParamter((int paramIndex,int jdbcType) throws SE
IN OUT :set it's value + registerOutParamter

5. Execute the proc/func
public boolean execute() throws SQLException

6. Retrieve the results stored in OUT param
API of CST
public Type getType(int paramIndex) throws SQLException

------------------------------------
Enter web programming in Java 
1. Refer to readme Java EE
2. Add web server (Tomcat) in your Java EE workspace.
3. Create Java EE compliant web application in IDE (dynamic web project)
4. Add home page (index.html) n test it.
5. Enter Servlets : Pending !






