The six architectural constraints of REST APIs

1. Client-server architecture
An API’s job is to connect two pieces of software without limiting their own functionalities. This objective is one of the core restrictions of REST: the client (that makes requests) and the server (that gives responses) stay separate and independent.

When done properly, the client and server can update and evolve in different directions without having an impact on the quality of their data exchange. This is especially important in various cases where there are plenty of different clients a server has to cater to. Think about weather APIs — they have to send data to tons of different clients (eg : web app , mobile native apps) from a single database.

2. Statelessness
For an API to be stateless, it has to handle calls independently of each other. Each API call has to contain the data and commands necessary to complete the desired action.

An example of a non-stateless API would be if, during a session, only the first call has to contain the API key, which is then stored server-side. The following API calls depend on that first one since it provides the client’s credentials.

In the same case, a stateless API will ensure that each call contains the API key and the server expects to see proof of access each time.

Stateless APIs have the advantage that one bad or failed call doesn’t derail the ones that follow.
The disadvantage is when the client needs to send too much data to the server so it  requires more bandwidth.



3. Uniform Interface
It is a important constraint that differentiate between a REST API and Non-REST API. 

It suggests that there should be an uniform way of interacting with a given server irrespective of device or type of application (eg : web app , mobile native apps) 

Guide lines 

3.1 Resource-Based: Individual resources are identified in requests. eg :  api/users
refer to diag : emp resource URIs
3.2 Manipulation of Resources Through Representations: 

Client has representation of resource and it contains enough information to update or delete the resource on the server, provided it has permission to do so. 
eg : User gets a user ids when user request for a list of users and then can use a specific id to delete or modify that particular user.
3.3 Self-descriptive Messages: Each message includes enough information to describe how to process the message so that server can easily analyses the request.
3.4 Hypermedia as the Engine of Application State (HATEOAS): It need to include links for each response so that client can discover other resources easily.
3.5 Stateless: Covered earlier

4. Layered system
To keep the API easy to understand and scale, RESTful architecture dictates that the design is structured into layers that operate together.

With a clear hierarchy for these layers, executing a command means that each layer does its function and then sends the data to the next one. Connected layers communicate with each other, but not with every component of the program. This way, the overall security of the API is also improved.

If the scope of the API changes, layers can be added, modified, or taken out without compromising other components of the interface.

5. Cacheability
It’s not uncommon for a stateless API’s requests to have large overhead. In some cases, that’s unavoidable, but for repeated requests that need the same data, caching said information can make a huge difference.

The concept is simple: the client has the option to locally store certain pieces of data for a predetermined period of time. When they make a request for that data, instead of the server sending it again, they use the stored version.

The result is simple: instead of the client sending several difficult or costly requests in a short span of time, they only have to do it once.

6. Code on Demand
Unlike the other constraints we talked about up to this point, the last one is optional. The reason for making “code on demand” optional is simple: it can be a large security risk.

The concept is to allow code or applets(now obsolete!) to be sent through the API and used for the application. As you can imagine, unknown code from a shady source could do some damage, so this constraint is best left for internal APIs where you have less to fear from hackers and people with bad intentions. Another drawback is that the code has to be in the appropriate programming language for the application, which isn’t always the case.

The upside is that “code on demand” can help the client implement their own features on the go, with less work being necessary on the API or server. In essence, it permits the whole system to be much more scalable and agile.