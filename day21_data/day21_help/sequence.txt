Revision

Confirm DB Setups
1. dac22
Simpler version of CMS : users , topics , tutorials
(ref : Java EE help\day1_help\jdbc help\sql\topics-tutorials.txt)
2. Complete version of CMS 
day20-data\day20_help\CMS DML.txt

Revise Spring boot validations n exc handling
Spring boot internals
2 way data binding(model <-----> view)
DTO , Entities n Model Mapper
Spring Boot AOP 
Simple microservices demo
--------------------------------------
Revision
1. Revise  Server side Validations n centralized exc handling
(refer : templates under ready code & "regarding spring boot exc handling n validations.txt")
Steps for validations 

1.0 Add validation spring boot starter

1.1 Add Validation rules on Entity (Think : is it logical to add them in the entity or separate DTO? : DTO)
first name n last name : can't be blank .(min : 4 chars , max =20 chars)
valid email 
valid strong password 
salary in the range : 10,000 --50,000
join date must be in future
Test it with postman client
(Same annotations can be also used in Spring MVC App , in P.L: presentation logic validations)
eg : @NotNull, @NotBlank,@Pattern....

1.2 Add @Valid annotation along with @RequestBody.

1.3 For validating request params or path vars :
Add @Valid annotation along with @RequestParam or @PathVariable +
Add @Validated on class level.
To DO !!!!!!!!!!!!!!!

1.4. Any problems observed on the client side ? : 
YES : since spring boot uses def. exc handler , entire stack trace , along with exc details are sent to the front end.
Meaning : Validation failures CAN NOT be caught by controller method level exc handling(try-catch)
B.L faliures CAN BE caught by controller method level exc handling(try-catch) --> but resulting into repeatative exc handling 
Instead : 
How to avoid  ?
Solution : Add centralized ( global) exc handler
Steps
1. Create a separate class : extending from ResponseEntityExcHandler (so that err resp will sent back as a resp entity) n can override base class methods
2. Add cls level anno : @ControllerAdvice
To tell SC , following class is a common advice to : controllers n rest controller --regarding exc handling (cross cutting concern=common task)
3. For validation failures : @Valid
override the method : handleMethodArgNotValidExc
Extract map of Field Errors from BindingResult --send it to the caller(front end) by wrapping it in the RespEntity.



2. Spring boot internals explained : 
Important components of a Spring Boot Application

Below is the starting point of a Spring Boot Application

@SpringBootApplication
public class HelloSpringBootApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloSpringBootApplication.class, args);
	}

}
About : org.springframework.boot.SpringApplication
It's Class  used to bootstrap and launch a Spring application from a Java main method. 

By default class will perform the following steps to bootstrap the application
1. Create an ApplicationContext instance (representing SC)
2. Manages life cycle of spring beans
3. Launches embedded Tomcat container


@SpringBootApplication - This is where all the spring boot magic happens.
It consists of following 3 annotations.

1. @SpringBootConfiguration
It  tells spring boot  that this class here can have several bean definitions. We can define various spring beans here and those beans will be available at run time .

2. @EnableAutoConfiguration
It tells spring boot to automatically configure the spring application based on the dependencies that it sees on the classpath.

eg:
If we have a MySql dependency in our pom.xml , Spring Boot will automatically create a data source,using the properties in application.properties file.  

If we have spring web in pom.xml , then spring boot will automatically create the dispatcher servlet n other beans (HandlerMapping , ViewResolver)

All the xml, all the java based configuration is now gone.It all comes for free thanks to spring boot to enable auto configuration annotation. 

3. @ComponentScan (equivalent to xml tag : context:component-scan)

So this  tells us that spring boot to  scan through the classes and see which all classes are marked with the stereotype annotations like @Component Or @Service @Repository and manage  these spring beans . Default base-pkg is the pkg in which main class is defined.
Can be overridden by
eg : 
@ComponentScan(basePackages = "com")
For scanning entities :  (equivalent to packagesToScan)
@EntityScan(basePackages = "com.app.pojos")


3. 2 way data binding n a readme : "regarding form binding"
ref : day20_spring_boot_cms
Practice Spring Data JPA
IUserDao extends JpaRepo
//User authenticateUser(String email,String pass);
Optional<User> findByEmailAndPassword(String email,String pass);

ITopicDao extends JpaRepo
//List<Topic> getAllTopics();
Inherited from JpaRepo  : List<Topic> findAll()

ITutorialDao extends JpaRepo


//List<Tutorial> getTutorialByTopic(long topicId);=> find all tuts under specific topic id
finder method
List<Tutorial> findByTopicId(long topicId);

@Query("select t.tutName from Tutorial t where t.topic.id=?1")
List<String> getTutorialNamesByTopicId(long topicId);


//Tutorial getTutorialDetails(String tutName);
Optional<Tutorial> findByTutName(String nm);


String addNewTutorial(Tutorial tut,long topicId);
inherited CrudRepo : save
Service :
get topic by it's id : findById --> orElseThrow --> Topic
establish uni dir tut --> topic relation
tut.setTopic(topic);
tutRepo.save(tut);
upon commit --> tut rec inserted + FK assigned !


Optional Lab work after revision : After completing pending work , Convert it into REST backend


4. Is it a good programming practice to mix up JPA managed entities with request n resposne payload NO
(i.e should you expose your entities as the JSON payloads: NO)

Apply the separation between entities n DTO
Which annotations will be applied where ?
Entity class : @Entity , @Table , Lombok annotations(@Getter, @Setter....) , @Column , @OneToOne...
Request DTO class : Lombok annotations(@Getter, @Setter....)  , P.L validation annotations(eg : @NotBlank,@NotNull....)
Response DTO class : Lombok annotations(@Getter, @Setter....)


In case of such multiple entity <----> DTO mappings , should you be doing it or delegate it to 3rd party  : 3rd party

Ref eclipse project :day21.1

For more details on ModelMapper API
ref :  https://www.baeldung.com/java-modelmapper
Model Mapper Maven
<!-- https://mvnrepository.com/artifact/org.modelmapper/modelmapper -->
<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>3.0.0</version>
</dependency>

How to configure model mapper bean , with STRICT mapping instructions
@Bean
public ModelMapper mapper()
{
 ModelMapper modelMapper = new ModelMapper();
 modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
 return modelMapper;
}

Use this n solve user login again.(ref : day20_lab)
In case of auth err : send err code : HTTP 401 

4. Spring AOP : exam objective

Before that :
Regarding logging framework in Java

Spring Boot being extremely  helpful framework , it allows us to forget about the majority of the configuration settings, many of which it opinionatedly auto-tunes.

In the case of logging, we don't have to explicitly import it's starter , since a starter, like our spring-boot-starter-web, depends on spring-boot-starter-logging, which already pulls in spring-jcl for us.

(Jakarta Commons Logging API (JCL) is the only mandatory external dependency for Spring w/o boot)

When using starters, Logback is used for logging by default.

eg : different logging levels
Add one field in the Controller class :
Logger logger = LoggerFactory.getLogger(LoggingController.class);
OR use Lombok annotation
@SLF4J : at the class level -- It will auto inject a Logger in the field : log

eg : 
@RestController
public class LoggingController {

    Logger logger = LoggerFactory.getLogger(LoggingController.class);

    @RequestMapping("/")
    public String index() {
//it's in asc manner : logging levels
        logger.trace("A TRACE Message");
        logger.debug("A DEBUG Message");
        logger.info("An INFO Message");
        logger.warn("A WARN Message");
        logger.error("An ERROR Message");

        return "Testing logging here....";
    }
}

Default setting in application.properties file : 
logging.level.root=INFO 
OR can also be mentioned in : logback-spring.xml , under <resources> : classpath
eg : logging.level.org.springframework.orm.hibernate5=DEBUG
logging.level.com.app.service=DEBUG



Enter AOP
NOTE : for adding AOP  : spring boot aop starter is not required.
AOP Basics
Before n After demos
@Around advice
Use @Around from AOP , to measure the time taken for servicing of client request. 
ref project : spring-boot-aop


5. Set up RestTemplate demo. (Microservices demo)
refer to diag : day20-data\day20_help\diagrams\RESTful webservice layers.png
(lower half of the diagram)
Objective :
Get emp's a/c details
eg : http://host:port/employees/{empId}/accounts/{acctNo}

Banking DB : dac22_banking

5.1 NetBanking REST Server
(ready made code)
Spring boot project : NetBankingRESTServer

5.2 Employee App REST Server for React App & client to NetBanking
5.3 Front end Postman (later add it in React app)

Details
2. Objective : Testing E-R with REST API + REST Client(RestTemplate)
Test setup : Postman -- Emp Management API invoking REST Banking API

Get Account summary for a bank customer.
Resource : /accounts
I/P : account no
O/P : In case of success :account details , o.w resource not found .


Layers on Netbanking server
REST Controller --Service --Repository--POJO --DB
Customer 1<------* BankAccount
Customer : customer id(do not auto generate , use assigned id : just to show example) ,name, password 

BankAccount : acct id (auto generation) AcctType(enum) ,balance + Customer owner



How to make a REST call from one web app to another  ?
Use : org.springframework.web.client.RestTemplate

The RestTemplate class in Spring Framework is a synchronous HTTP client for making HTTP requests to consume RESTful web services. 

It exposes a simple and easy-to-use template method API for sending an HTTP request and also handling the HTTP response. 

The RestTemplate class also provides aliases for all supported HTTP request methods, such as GET, POST, PUT, PATCH , DELETE, and OPTIONS. 

In a service layer : inject

public class ClntService {
private RestTemplate template;

	@Autowired //autowire=constructor
	public ClntService(RestTemplateBuilder builder) {
		template = builder.build();
	}


}
	// SpEL : spring expression language
	@Value("${REST_AUTH_URL}")
	private String authUrl;

Use  Method of o.s.w.c.RestTemplate public <T> ResponseEntity<T>
		  postForEntity(String url,@Nullable Object request, Class<T> responseType, Object... uriVariables)  throws RestClientException

Req Object : LoginRequest		
Resp Type : DTO : BankAccounts
	
-------------------------------------------------------------------------------------------------------------------
Important Project Tips :
1 Typically add : ManyToOne : lazy

2. To control json data during serialization / de-serial
2.1 Add @JsonIgnore : at field level
2.2 @JsonIgnore on a property getter : to  ignore this property while serialization(marshalling)
2.3 @JsonProperty  on a property setter if you don't want to  ignore this property while de serialization(un marshalling)

3.To tell serilizer n de-serializer(java---> json , json ---> java), done auto by SC , using Jackson API
to ignore the asso properties added in bi dir asso.
Add : @JsonIgnoreProperties("name of the association property")
--------------------
Troubleshooting tips

Additional Cleaning Instructions
R Click on the project--Run As --Maven Clean
Then Project clean
Refresh

