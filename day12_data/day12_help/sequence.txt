Revise Hibernate architecture
CRUD operations
BLOB Handling
E-R 


Important Blocks 
1.org.hibernate.Session : interface (imple classes : hibernate core jar)
Represents : Main runtime i/f for prog interaction with hibernate
Supplies CRUD APIs(eg : save, persist, get,load, createQuery,update,delete....)
Represents : wrapper around pooled out db connection. 
It has INHERENTLY L1 cache(persistence ctx)  associated with it.
DAO layer creates session instance as per demand(one per request for CRUD operation)
light weight , thread un safe object
NO NEED for accessing the session in synchronized manner : since different thrd representing different clnt requests , will have their own session object

2. org.hibernate.SessionFactory : interface (imple classes : hibernate core jar)
JOB : to provide session objects(openSession / getCurrentSession)
singleton instance per DB / application
immutable , inherently thread safe
Represents : DB sepecific config , including connection pool.
It has L2 cache associated with it : MUST be configured explcitly

3. Configuration : org.hibernate.cfg.Configuration class.
Provider of SF

4. Additional APIs
, Transaction,Query,CriteriaQuery ...


5. hibernate.cfg.xml : centralized configuration file , to create SessionFactory(i.e bootstrapping hibernate framework)

Important property : 
hibernate.hbm2ddl.auto=update
Chks if table is not yet created for a POJO : create a new table.
BUT if table alrdy exists : continues with the existing table.

5.5 HibernateUtils --- to create singleton immutable SF instance


6.
POJO Annotations 

Package : javax.persistence
@Entity : Mandatory : cls level
@Id : Mandatory : field level or property (getter) : PK

Optional annotation for further customization : 

@Table(name="tbl_name) : to specify table name n more

@GeneratedValue : to tell hibernate to auto generate ids
auto / identity(auto incr : Mysql) / table / sequence(oracle)
eg : @Id => PK 
@GeneratedValue(strategy=GenarationType.IDENTITY) => auto increment

@Column(name,unique,nullable,insertable,updatable,length,columnDefinition="double(8,2)") : for specifying col details

@Transient : Skipped from persistence(no col will be generated in DB table)

@Temporal : java.util.Date , Calendar , GregorianCalendar

LocalDate(date) ,LocalTime(time) ,  LocalDateTime (timestamp/datetime) : no temporal anno.

@Lob : BLOB(byte[])  n CLOB(char[]) : saving / restoring large bin /char data to/from DB

@Enumerated (EnumType.STRING): enum (def : ordinal : int)


 Add <mapping class="F.Q POJO class name"/> in hibernate.cfg.xml


7. Create DAO i/f & write its implementation class 
Hibernate  based DAO impl class

7.1 No data members ,constructor , cleanup
7.2 Directly add CRUD methods.

Steps in CRUD methods
1. Get hib session from SF
API of org.hibernate.SessionFactory
public Session openSession() throws HibernateException
OR
public Session getCurrentSession() throws HibernateException

2. Begin a Transaction
API of Session
public Transaction beginTransaction()throws HibernateException

3. try {
  perform CRUD using Session API (eg : save/get/persist/update/delete/JPQL...)
  commit the tx.
   } catch(RuntimeException e)
   {
      roll back tx.
      re throw the exc to caller
   } finally {
      close session --destroys L1 cache , pooled out db cn rets to the pool.
   }


4 Refer to Hibernate Session API 
(hibernate api-docs & readme : hibernate session api)

5. Create main(..) based Tester & test the application.

Which of the following layers are currently hibernate specific(native hibernate) ?

DAO : org.hibernate.SF , Session, Transaction,Query... : hibernate specific
POJO : javax.persistence : annotations => hibernate  inde. (JPA compliant)
Utils : Configuration , org.hibernate.SF => hibernate specific



6. Add a breakpoint before commit , observe n conclude.

7. Replace openSession by getCurrentSession


8. Objective : Get user details
I/P : user id
O/P : User details or error 
API : session.get

9. Confirm L1 cache
by invoking session.get(...) multiple times.

10. Hibernate POJO states :
transient , persistent , detached.

11. Objective : Display all user details
Can you solve it using session.get ? : NO 
sql : "select * from users_tbl"
hql : from User
jpql : select u from User u
u : POJO alias (ref)


11.1 Solve it using HQL(Hibernate query language)/JPQL (Java Persistence Query Language)

Object oriented query language, where table names are replaced by POJO class names & column names are replaced by POJO property names, in case sensitive manner.


11.2. Create Query Object --- from Session i/f
<T> org.hibernate.query.Query<T> createQuery(String jpql/hql,Class<T> resultType)
T --result type.

11.3. To execute query
Query i/f method
public List<T> getResultList() throws HibernateException
--Rets list of PERSISTENT entities.
-------------------------Completed so far-------------------

12. Objective : Display all users registered between strt date n end date & under a specific role
I/P : begin dt , end date , role
eg : sql = select * from users where reg_date between ? and ? and user_role=?
 jpql : select u from User u where u.regDate between :strt_date and :end_date and u.userRole=:role

Passing named  IN params to the query
Query i/f method
public Query<T> setParameter(String paramName,Object value) throws HibernateException.


13. User Login (Lab work)
i/p : email n password
o/p User details with success mesg or invalid login mesg

14. Objective : Display all user names registered after specific date
jpql = select u.name from User u where u.regDate > :dt

15 Objective : Display all user's last name,reg amount,reg date registered between strt date n end date 

List<Object[]> list=session.createQuery(jpql,Object[].class).setParameter("start", startDate).setParameter("end", endDate).getResultList();
In Tester : 
list.forEach(o -> sop(o[0]+" "+o[1]+"  "+o[2]));

INSTEAD use a constructor expression
eg :
jpql = "select new pojos.User(lastName,regAmount,regDate) from User u where u.regDate between :strt and :end and userRole=:rl";

Pre requisite : MATCHING constr in POJO class

17. Update 
Objective : 
1. Change password
i/p --user id , new pass
o/p : mesg indicating success or a failure



2. Apply discount to reg amount , for all users , reged before a specific date.(Bulk update)
i/p -- discount amt, reg date
jpql="select u from User u where u.regDate < :dt";
List<User> users=sesison.createQuery(jpql,User.class).setParameter("dt",date).getResultList();//select
users.forEach(user -> user.setRegAmount(user.getRegAmount-discount));
tx.commit();//n update queries

OR 

String jpql="update User u set u.regAmount=u.regAmount-:disc where u.regDate < :dt";

2.1 Query API
public int executeUpdate() throws HibernateException
--use case --DML
2.2 Session API
public Query<T> createQuery(String jpql) throws HibernateException
jpql -- DML


18. Un subscribe user
i/p user email
o/p user details removed from DB
Hint : Session API : delete

19. Lab work
Objective --delete vendor details for those vendors reg date > dt.
via Bulk delete
String jpql="delete from Vendor v where v.regDate > :dt";

------------------------------
20. Save n restore images to / from DB
FileUtils from Apache commons-io


Objective : Store image for a specific user
i/p : user id , image path(path n filename)
o/p : mesg


Objective : ReStore image for a specific user
i/p : user id , image path(path n filename)
o/p : mesg


NOTE :
MySQL supports 4 types of BLOB data types, which only differ in the maximum length of data they can store. 

TINYBLOB: Only supports up to 255 bytes.
BLOB: Can handle up to 65,535 bytes of data.
MEDIUMBLOB: The maximum length supported is 16,777,215 bytes.
LONGBLOB: Stores up to 4,294,967,295 bytes of data.

NOTE : Even though , these are default values for MySQL , DB throws exception , even when your are trying to save LONGBLOB > few MBs.

Suggested solution before spring boot
To change the max allowed packet for everyone to 1GB until the server restarts:
SET GLOBAL max_allowed_packet=1073741824;





Methods 

1. public static byte[] readFileToByteArray(File file)
                                  throws IOException
Reads the contents of a file into a byte array. The file is always closed.

2. public static void writeByteArrayToFile(File file,
                        byte[] data)
                                 throws IOException
Writes a byte array to a file creating the file if it does not exist.

-------------------------
Enter E-R

